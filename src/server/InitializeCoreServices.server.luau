-- InitializeCoreServices.server.luau
-- Enterprise-grade service initialization using dependency injection
-- Completely eliminates global state pollution using ServiceContainer
-- Place this in ServerScriptService for automatic execution

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Import our dependency injection infrastructure
local ServiceContainer = require(ReplicatedStorage.Shared.core.ServiceContainer)
local ServiceInterface = require(ReplicatedStorage.Shared.core.ServiceInterface)
local BaseService = require(ReplicatedStorage.Shared.core.BaseService)
local ConfigurationManager = require(ReplicatedStorage.Shared.core.ConfigurationManager)
local ConfigurationValidators = require(ReplicatedStorage.Shared.core.ConfigurationValidators)

print("üöÄ Initializing Enterprise Service Container with Configuration Management...")

-- ========================================
-- CONFIGURATION SYSTEM SETUP
-- ========================================

-- Initialize configuration system first (before any services)
print("üîß Initializing Configuration System...")
local configManager = ConfigurationManager.getInstance()

-- Register all configuration validators
ConfigurationValidators.registerAllValidators(configManager)

-- Validate all configurations
local isValid = configManager:_validateAllConfigurations()
if not isValid then
    local errors = configManager:GetValidationErrors()
    warn("üö® Configuration validation failed:")
    for _, error in ipairs(errors) do
        warn("  ‚ùå " .. error.path .. ": " .. error.error)
    end
    error("Configuration validation failed - cannot start services")
end

print("‚úÖ Configuration system initialized and validated")
print("üìä Environment: " .. configManager:GetEnvironment())

-- ========================================
-- SERVICE CONTAINER SETUP
-- ========================================

local container = ServiceContainer.new("CoreGameContainer")
local loadedCount = 0
local totalServices = 11

-- Register ConfigurationManager as a singleton first
container:RegisterSingleton("ConfigurationManager", configManager)

-- ========================================
-- SERVICE REGISTRATION FUNCTIONS
-- ========================================

local function RegisterService(serviceName, modulePath, dependencies, interface)
    dependencies = dependencies or {}
    
    print("üì¶ Registering service: " .. serviceName)
    
    local success, err = pcall(function()
        -- Register the service with the container
        container:RegisterFactory(serviceName, function()
            local serviceModule = require(modulePath)
            
            -- Create service instance
            local serviceInstance
            if serviceModule.new then
                serviceInstance = serviceModule.new()
            elseif serviceModule.Create then
                serviceInstance = serviceModule:Create()
            else
                serviceInstance = serviceModule
            end
            
            -- Set service name if it has a name property
            if serviceInstance and type(serviceInstance) == "table" and serviceInstance.name == nil then
                serviceInstance.name = serviceName
            end
            
            return serviceInstance
        end, dependencies, interface)
        
        loadedCount = loadedCount + 1
        print("‚úÖ " .. serviceName .. " registered successfully")
    end)
    
    if not success then
        warn("‚ùå Failed to register " .. serviceName .. ": " .. tostring(err))
    end
end

local function RegisterSingleton(serviceName, instance)
    print("üîÑ Registering singleton: " .. serviceName)
    
    local success, err = pcall(function()
        container:RegisterSingleton(serviceName, instance)
        loadedCount = loadedCount + 1
        print("‚úÖ " .. serviceName .. " singleton registered successfully")
    end)
    
    if not success then
        warn("‚ùå Failed to register singleton " .. serviceName .. ": " .. tostring(err))
    end
end

-- ========================================
-- REGISTER CORE SERVICES
-- ========================================

print("\nüîß Registering Core Services...")

-- First, register MemoryManager as a singleton (now uses ConfigurationManager)
print("0/11 Registering MemoryManager...")
local MemoryManager = require(ReplicatedStorage.Shared.utilities.MemoryManager)
MemoryManager:Init()
RegisterSingleton("MemoryManager", MemoryManager)

-- 1. GameService (Core game mechanics)
print("1/11 Registering GameService...")
RegisterService(
    "GameService",
    script.Parent.services.core.GameService,
    {"MemoryManager", "ConfigurationManager"},
    ServiceInterface.IGameService
)

-- 2. AnalyticsService (Event tracking)
print("2/11 Registering AnalyticsService...")
RegisterService(
    "AnalyticsService", 
    script.Parent.services.AnalyticsService,
    {"MemoryManager", "ConfigurationManager"},
    ServiceInterface.IAnalyticsService
)

-- 3. TrackGeneratorService (Track creation)
print("3/11 Registering TrackGeneratorService...")
RegisterService(
    "TrackGeneratorService",
    script.Parent.services.TrackGeneratorService,
    {"MemoryManager", "AnalyticsService", "ConfigurationManager"},
    ServiceInterface.IService
)

-- 4. DifficultyService (Dynamic difficulty)
print("4/11 Registering DifficultyService...")
RegisterService(
    "DifficultyService",
    script.Parent.services.DifficultyService,
    {"MemoryManager", "AnalyticsService", "ConfigurationManager"},
    ServiceInterface.IService
)

-- ========================================
-- REGISTER CONTROLLERS
-- ========================================

print("\nüéÆ Registering Controllers...")

-- 5. MainGameController (Central game management)
print("5/11 Registering MainGameController...")
RegisterService(
    "MainGameController",
    script.Parent.MainGameController,
    {"GameService", "AnalyticsService", "TrackGeneratorService", "DifficultyService", "MemoryManager", "ConfigurationManager"},
    ServiceInterface.IService
)

-- 6. CollisionController (Collision detection)
print("6/11 Registering CollisionController...")
RegisterService(
    "CollisionController",
    script.Parent.controllers.CollisionController,
    {"MainGameController", "MemoryManager", "ConfigurationManager"},
    ServiceInterface.IService
)

-- ========================================
-- REGISTER ENHANCEMENT SERVICES
-- ========================================

print("\nüåü Registering Enhancement Services...")

-- 7. RecordingSessionManager (Recording management)
print("7/11 Registering RecordingSessionManager...")
local recordingPath = script.Parent.services:FindFirstChild("RecordingSessionManager.server") or
                     script.Parent.services:FindFirstChild("RecordingSessionManager")
if recordingPath then
    RegisterService(
        "RecordingSessionManager",
        recordingPath,
        {"MemoryManager", "AnalyticsService", "ConfigurationManager"},
        ServiceInterface.IService
    )
else
    warn("‚ö†Ô∏è RecordingSessionManager module not found")
    totalServices = totalServices - 1
end

-- 8. MovingObstacleService (Moving obstacles)
print("8/11 Registering MovingObstacleService...")
RegisterService(
    "MovingObstacleService",
    script.Parent.services.MovingObstacleService,
    {"MemoryManager", "AnalyticsService", "ConfigurationManager"},
    ServiceInterface.IService
)

-- 9. SystemEventConnections (Event binding and connections)
print("9/11 Registering SystemEventConnections...")
RegisterService(
    "SystemEventConnections",
    script.Parent.SystemEventConnections,
    {"MemoryManager", "ConfigurationManager"},
    ServiceInterface.IService
)

-- 10. GameStateEventManager (Game state event management)
print("10/11 Registering GameStateEventManager...")
RegisterService(
    "GameStateEventManager",
    script.Parent.GameStateEventManager,
    {"MemoryManager", "AnalyticsService", "GameService", "ConfigurationManager"},
    ServiceInterface.IService
)

-- 11. GameLifecycleManager (Complete lifecycle management)
print("11/11 Registering GameLifecycleManager...")
RegisterService(
    "GameLifecycleManager",
    script.Parent.GameLifecycleManager,
    {"MemoryManager", "GameService", "MainGameController", "AnalyticsService", "ConfigurationManager"},
    ServiceInterface.IService
)

-- ========================================
-- INITIALIZE CONTAINER AND START SERVICES
-- ========================================

print("\n‚ö° Initializing Service Container...")

-- Initialize the container (resolves all dependencies)
local initSuccess, initError = pcall(function()
    container:Initialize()
end)

if not initSuccess then
    error("üö® CRITICAL: Failed to initialize service container: " .. tostring(initError))
end

print("‚úÖ Service container initialized successfully")

-- Start all services
print("\nüöÄ Starting all services...")
local startSuccess, startError = pcall(function()
    container:StartAll()
end)

if not startSuccess then
    warn("‚ö†Ô∏è Some services failed to start: " .. tostring(startError))
end

print("‚úÖ All services started")

-- ========================================
-- CREATE SERVICE ACCESSOR (Replaces _G pollution)
-- ========================================

print("\nüîó Setting up Service Access Layer...")

-- Create a clean service accessor that replaces _G usage
local ServiceLocator = {}

-- Core service accessor functions (replaces _G functions)
function ServiceLocator.GetGameService()
    return container:GetService("GameService")
end

function ServiceLocator.GetAnalyticsService()
    return container:GetService("AnalyticsService")
end

function ServiceLocator.GetTrackGeneratorService()
    return container:GetService("TrackGeneratorService")
end

function ServiceLocator.GetDifficultyService()
    return container:GetService("DifficultyService")
end

function ServiceLocator.GetMainGameController()
    return container:GetService("MainGameController")
end

function ServiceLocator.GetCollisionController()
    return container:GetService("CollisionController")
end

function ServiceLocator.GetRecordingSessionManager()
    return container:TryGetService("RecordingSessionManager")
end

function ServiceLocator.GetMovingObstacleService()
    return container:GetService("MovingObstacleService")
end

function ServiceLocator.GetSystemEventConnections()
    return container:GetService("SystemEventConnections")
end

function ServiceLocator.GetGameStateEventManager()
    return container:GetService("GameStateEventManager")
end

function ServiceLocator.GetGameLifecycleManager()
    return container:GetService("GameLifecycleManager")
end

function ServiceLocator.GetMemoryManager()
    return container:GetService("MemoryManager")
end

function ServiceLocator.GetConfigurationManager()
    return container:GetService("ConfigurationManager")
end

-- Generic service accessor
function ServiceLocator.GetService(serviceName)
    return container:GetService(serviceName)
end

function ServiceLocator.TryGetService(serviceName)
    return container:TryGetService(serviceName)
end

-- Utility functions
function ServiceLocator.ListServices()
    return container:ListServices()
end

function ServiceLocator.GetServiceStatus()
    return container:GetDiagnostics()
end

function ServiceLocator.GetContainer()
    return container
end

-- Store ServiceLocator in ReplicatedStorage for client access
if not ReplicatedStorage:FindFirstChild("ServiceLocator") then
    local serviceLocatorValue = Instance.new("ModuleScript")
    serviceLocatorValue.Name = "ServiceLocator"
    serviceLocatorValue.Source = [[
        -- Auto-generated ServiceLocator for client access
        -- DO NOT EDIT - This is automatically updated by InitializeCoreServices
        local ServiceLocator = ]] .. game:GetService("HttpService"):JSONEncode({
            initialized = true,
            containerName = "CoreGameContainer"
        }) .. [[
        
        return ServiceLocator
    ]]
    serviceLocatorValue.Parent = ReplicatedStorage
end

-- IMPORTANT: Store the ServiceLocator in a way that doesn't pollute _G
ReplicatedStorage:SetAttribute("ServiceLocatorReady", true)

-- For backward compatibility during transition, create deprecated _G accessors
-- These will be removed in Phase 2 of the cleanup
local function CreateDeprecatedAccessor(funcName, newFunc)
    _G[funcName] = function(...)
        warn("DEPRECATED: _G." .. funcName .. " is deprecated. Use ServiceLocator." .. funcName .. " instead.")
        return newFunc(...)
    end
end

-- Create deprecated accessors (to be removed)
CreateDeprecatedAccessor("GetGameService", ServiceLocator.GetGameService)
CreateDeprecatedAccessor("GetAnalyticsService", ServiceLocator.GetAnalyticsService)
CreateDeprecatedAccessor("GetTrackGeneratorService", ServiceLocator.GetTrackGeneratorService)
CreateDeprecatedAccessor("GetDifficultyService", ServiceLocator.GetDifficultyService)
CreateDeprecatedAccessor("GetMainGameController", ServiceLocator.GetMainGameController)
CreateDeprecatedAccessor("GetCollisionController", ServiceLocator.GetCollisionController)
CreateDeprecatedAccessor("GetRecordingSessionManager", ServiceLocator.GetRecordingSessionManager)
CreateDeprecatedAccessor("GetMovingObstacleService", ServiceLocator.GetMovingObstacleService)
CreateDeprecatedAccessor("GetSystemEventConnections", ServiceLocator.GetSystemEventConnections)
CreateDeprecatedAccessor("GetGameStateEventManager", ServiceLocator.GetGameStateEventManager)
CreateDeprecatedAccessor("GetGameLifecycleManager", ServiceLocator.GetGameLifecycleManager)
CreateDeprecatedAccessor("GetCoreService", ServiceLocator.GetService)
CreateDeprecatedAccessor("ListCoreServices", ServiceLocator.ListServices)
CreateDeprecatedAccessor("GetCoreServiceStatus", ServiceLocator.GetServiceStatus)

print("‚ö†Ô∏è Deprecated _G accessors created for backward compatibility")
print("üìç Use ServiceLocator instead of _G for service access")

-- ========================================
-- FINAL VALIDATION AND SUMMARY
-- ========================================

print("\nÔøΩ Initialization Summary:")
print("=" .. string.rep("=", 60))

-- Get container diagnostics
local diagnostics = container:GetDiagnostics()
print("‚úÖ Services registered: " .. loadedCount .. "/" .. totalServices)
print("üèóÔ∏è Container status: " .. diagnostics.status)
print("üîó Dependency graph valid: " .. tostring(diagnostics.dependencyGraphValid))

-- List registered services
print("\nüìã Registered Services:")
local serviceNames = container:ListServices()
for _, serviceName in ipairs(serviceNames) do
    local service = container:TryGetService(serviceName)
    local status = service and "‚úÖ ACTIVE" or "‚ùå FAILED"
    print("  " .. status .. " " .. serviceName)
end

-- Check for critical failures
local criticalServices = {
    "GameService",
    "MainGameController", 
    "AnalyticsService",
    "TrackGeneratorService",
    "MemoryManager"
}

local criticalFailures = {}
for _, serviceName in ipairs(criticalServices) do
    if not container:TryGetService(serviceName) then
        table.insert(criticalFailures, serviceName)
    end
end

if #criticalFailures > 0 then
    warn("üö® CRITICAL SERVICES FAILED:")
    for _, serviceName in ipairs(criticalFailures) do
        warn("  ‚ùå " .. serviceName)
    end
    warn("‚ö†Ô∏è Game may not function properly!")
else
    print("‚úÖ All critical services active")
end

-- Performance metrics
print("\nüìà Performance Metrics:")
print("  üïê Total initialization time: " .. string.format("%.2fs", diagnostics.totalInitializationTime or 0))
print("  üß† Memory overhead: " .. (diagnostics.memoryOverhead or "unknown"))
print("  üîÄ Services with dependencies: " .. (diagnostics.servicesWithDependencies or 0))

print("=" .. string.rep("=", 60))

if loadedCount >= 6 then -- Allow for some optional services to fail
    print("üéÆ Enterprise Service Container Ready!")
    print("üìç Use ServiceLocator.GetService(name) for service access")
    print("üìç Use ServiceLocator.ListServices() to see all services")  
    print("üìç Use ServiceLocator.GetServiceStatus() for diagnostics")
    
    -- Run health check after initialization
    spawn(function()
        wait(5)
        print("üè• Running post-initialization health check...")
        local healthStatus = container:PerformHealthCheck()
        local healthyCount = 0
        
        for serviceName, health in pairs(healthStatus) do
            if health.isHealthy then
                healthyCount = healthyCount + 1
            else
                warn("ü©∫ Health issue in " .. serviceName .. ": " .. table.concat(health.issues, ", "))
            end
        end
        
        print("üíö Health check: " .. healthyCount .. "/" .. #serviceNames .. " services healthy")
    end)
else
    warn("‚ùå Insufficient services loaded - Game may not function!")
end

-- ========================================
-- PLAYER CONNECTION SETUP  
-- ========================================

print("\nüë• Setting up Player Management...")

-- Enhanced player management using dependency injection
Players.PlayerAdded:Connect(function(player)
    print("üëã Player joined: " .. player.Name)
    
    -- Get services through ServiceLocator instead of _G
    local gameService = ServiceLocator.TryGetService("GameService")
    local mainGameController = ServiceLocator.TryGetService("MainGameController")
    local analyticsService = ServiceLocator.TryGetService("AnalyticsService")
    local memoryManager = ServiceLocator.TryGetService("MemoryManager")
    
    -- Notify services about new player with error handling
    if gameService and gameService.OnPlayerAdded then
        pcall(function()
            gameService:OnPlayerAdded(player)
        end)
    end
    
    if mainGameController and mainGameController.OnPlayerAdded then
        pcall(function()
            mainGameController:OnPlayerAdded(player)
        end)
    end
    
    if analyticsService and analyticsService.TrackPlayerJoin then
        pcall(function()
            analyticsService:TrackPlayerJoin(player)
        end)
    end
    
    -- Initialize player-specific memory tracking
    if memoryManager and memoryManager.InitializePlayer then
        pcall(function()
            memoryManager:InitializePlayer(player)
        end)
    end
    
    print("‚úÖ Player " .. player.Name .. " processed by all services")
end)

Players.PlayerRemoving:Connect(function(player)
    print("üëã Player leaving: " .. player.Name)
    
    -- Get services through ServiceLocator
    local gameService = ServiceLocator.TryGetService("GameService")
    local mainGameController = ServiceLocator.TryGetService("MainGameController")
    local analyticsService = ServiceLocator.TryGetService("AnalyticsService")
    local memoryManager = ServiceLocator.TryGetService("MemoryManager")
    
    -- Clean up player from services with error handling
    if gameService and gameService.OnPlayerRemoving then
        pcall(function()
            gameService:OnPlayerRemoving(player)
        end)
    end
    
    if mainGameController and mainGameController.OnPlayerRemoving then
        pcall(function()
            mainGameController:OnPlayerRemoving(player)
        end)
    end
    
    if analyticsService and analyticsService.TrackPlayerLeave then
        pcall(function()
            analyticsService:TrackPlayerLeave(player)
        end)
    end
    
    -- Clean up player-specific memory tracking
    if memoryManager and memoryManager.CleanupPlayer then
        pcall(function()
            memoryManager:CleanupPlayer(player)
        end)
    end
    
    print("‚úÖ Player " .. player.Name .. " cleaned up from all services")
end)

print("‚úÖ Enhanced player management configured")

print("\nüéâ ENTERPRISE SERVICE CONTAINER INITIALIZATION COMPLETE!")
print("=" .. string.rep("=", 60))
print("üèóÔ∏è Architecture: Dependency Injection Container")
print("üßπ Global State Pollution: ELIMINATED") 
print("üîí Service Isolation: ENFORCED")
print("ÔøΩ Interface Contracts: VALIDATED")
print("ü©∫ Health Monitoring: ACTIVE")
print("üìä Performance Metrics: TRACKED")
print("=" .. string.rep("=", 60))

-- Return the ServiceLocator for external access
return ServiceLocator
