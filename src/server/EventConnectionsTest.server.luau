-- EventConnectionsTest.server.luau
-- Comprehensive test for all event connections and system bindings
-- Verifies player spawn logic, service linkages, and game state management

local Players = game:GetService("Players")

local EventConnectionsTest = {}

-- Test configuration
local TEST_CONFIG = {
    enableDetailedLogging = true,
    testTimeout = 30,
    runAutomaticTests = true
}

function EventConnectionsTest:Initialize()
    print("üß™ Initializing Event Connections Test Suite...")
    
    if TEST_CONFIG.runAutomaticTests then
        spawn(function()
            wait(10) -- Wait for all systems to load
            self:RunAllTests()
        end)
    end
    
    return true
end

function EventConnectionsTest:RunAllTests()
    print("\nüöÄ Running Event Connections Test Suite...")
    
    local results = {
        coreServicesTest = self:TestCoreServicesAvailability(),
        eventConnectionsTest = self:TestEventConnections(),
        serviceLinkageTest = self:TestServiceLinkages(),
        gameStateTest = self:TestGameStateManagement(),
        playerSpawnTest = self:TestPlayerSpawnLogic(),
        recordingBindingTest = self:TestRecordingBindings(),
        analyticsBindingTest = self:TestAnalyticsBindings(),
        systemResetTest = self:TestSystemResetBindings()
    }
    
    -- Print test results
    self:PrintTestResults(results)
    
    return results
end

-- ========================================
-- CORE SERVICES AVAILABILITY TEST
-- ========================================

function EventConnectionsTest:TestCoreServicesAvailability()
    print("üîç Testing Core Services Availability...")
    
    local services = {
        "GameService",
        "AnalyticsService", 
        "TrackGeneratorService",
        "DifficultyService",
        "MainGameController",
        "CollisionController",
        "RecordingSessionManager",
        "MovingObstacleService",
        "SystemEventConnections",
        "GameStateEventManager"
    }
    
    local results = {}
    
    for _, serviceName in ipairs(services) do
        local getter = _G["Get" .. serviceName]
        local service = getter and getter()
        
        results[serviceName] = {
            available = service ~= nil,
            hasGetter = getter ~= nil,
            service = service
        }
        
        if TEST_CONFIG.enableDetailedLogging then
            local status = service and "‚úÖ" or "‚ùå"
            print(status .. " " .. serviceName .. ": " .. (service and "Available" or "Missing"))
        end
    end
    
    return results
end

-- ========================================
-- EVENT CONNECTIONS TEST
-- ========================================

function EventConnectionsTest:TestEventConnections()
    print("üîó Testing Event Connections...")
    
    local systemConnections = _G.GetSystemEventConnections()
    if not systemConnections then
        warn("‚ùå SystemEventConnections not available")
        return {success = false, error = "SystemEventConnections missing"}
    end
    
    -- Test connection status
    local connectionStatus = systemConnections:GetConnectionStatus()
    
    local results = {
        success = true,
        systemConnectionsAvailable = true,
        connectionStatus = connectionStatus,
        expectedConnections = {
            "PlayerAdded",
            "PlayerRemoving", 
            "GameStateChange",
            "ScoreUpdate"
        }
    }
    
    if TEST_CONFIG.enableDetailedLogging then
        print("üìã Connection Status:")
        for name, status in pairs(connectionStatus.eventConnections) do
            local statusIcon = status and "‚úÖ" or "‚ùå"
            print("  " .. statusIcon .. " " .. name)
        end
    end
    
    return results
end

-- ========================================
-- SERVICE LINKAGE TEST
-- ========================================

function EventConnectionsTest:TestServiceLinkages()
    print("üîó Testing Service Linkages...")
    
    local linkageManager = _G.GetServiceLinkageManager and _G.GetServiceLinkageManager()
    local mainController = _G.GetMainGameController()
    local trackGenerator = _G.GetTrackGeneratorService()
    local collisionController = _G.GetCollisionController()
    
    local results = {
        success = true,
        linkageManagerAvailable = linkageManager ~= nil,
        mainControllerLinkages = {},
        bidirectionalCommunication = {}
    }
    
    -- Test MainController ‚Üí TrackGenerator linkage
    if mainController and trackGenerator then
        results.mainControllerLinkages.trackGenerator = {
            hasReference = mainController.TrackGeneratorService ~= nil,
            hasRequestMethod = mainController.RequestTrackGeneration ~= nil,
            hasGetCurrentTrack = mainController.GetCurrentTrack ~= nil
        }
        
        if TEST_CONFIG.enableDetailedLogging then
            local hasRef = mainController.TrackGeneratorService and "‚úÖ" or "‚ùå"
            print("  " .. hasRef .. " MainController ‚Üí TrackGenerator reference")
            
            local hasMethod = mainController.RequestTrackGeneration and "‚úÖ" or "‚ùå"
            print("  " .. hasMethod .. " MainController.RequestTrackGeneration method")
        end
    end
    
    -- Test MainController ‚Üí CollisionController linkage
    if mainController and collisionController then
        results.mainControllerLinkages.collisionController = {
            hasReference = mainController.CollisionController ~= nil,
            hasEnableMethod = mainController.EnableCollisionDetection ~= nil,
            hasDisableMethod = mainController.DisableCollisionDetection ~= nil
        }
        
        if TEST_CONFIG.enableDetailedLogging then
            local hasRef = mainController.CollisionController and "‚úÖ" or "‚ùå"
            print("  " .. hasRef .. " MainController ‚Üí CollisionController reference")
            
            local hasEnable = mainController.EnableCollisionDetection and "‚úÖ" or "‚ùå"
            print("  " .. hasEnable .. " MainController.EnableCollisionDetection method")
        end
    end
    
    -- Test bidirectional communication
    if collisionController and mainController then
        results.bidirectionalCommunication.collision = {
            collisionToMain = collisionController.NotifyPlayerCollision ~= nil,
            mainToCollision = mainController.HandlePlayerCollision ~= nil
        }
        
        if TEST_CONFIG.enableDetailedLogging then
            local toMain = collisionController.NotifyPlayerCollision and "‚úÖ" or "‚ùå"
            print("  " .. toMain .. " CollisionController ‚Üí MainController communication")
            
            local fromMain = mainController.HandlePlayerCollision and "‚úÖ" or "‚ùå"
            print("  " .. fromMain .. " MainController ‚Üê CollisionController communication")
        end
    end
    
    return results
end

-- ========================================
-- GAME STATE MANAGEMENT TEST
-- ========================================

function EventConnectionsTest:TestGameStateManagement()
    print("üéÆ Testing Game State Management...")
    
    local gameStateManager = _G.GetGameStateEventManager()
    if not gameStateManager then
        warn("‚ùå GameStateEventManager not available")
        return {success = false, error = "GameStateEventManager missing"}
    end
    
    local results = {
        success = true,
        gameStateManagerAvailable = true,
        playerStates = gameStateManager:GetAllPlayerStates(),
        globalState = gameStateManager:GetGlobalGameState(),
        hasStateChangeMethods = {
            changeGameState = gameStateManager.ChangeGameState ~= nil,
            getPlayerState = gameStateManager.GetPlayerState ~= nil,
            setGlobalGameState = gameStateManager.SetGlobalGameState ~= nil
        }
    }
    
    if TEST_CONFIG.enableDetailedLogging then
        print("üéÆ Global Game State: " .. tostring(results.globalState))
        
        local playerCount = 0
        for _ in pairs(results.playerStates) do
            playerCount = playerCount + 1
        end
        print("üë• Players with tracked states: " .. playerCount)
        
        for method, available in pairs(results.hasStateChangeMethods) do
            local status = available and "‚úÖ" or "‚ùå"
            print("  " .. status .. " " .. method .. " method")
        end
    end
    
    return results
end

-- ========================================
-- PLAYER SPAWN LOGIC TEST
-- ========================================

function EventConnectionsTest:TestPlayerSpawnLogic()
    print("üë• Testing Player Spawn Logic...")
    
    local playerSpawnLogic = _G.GetPlayerSpawnLogic and _G.GetPlayerSpawnLogic()
    
    local results = {
        success = true,
        playerSpawnLogicAvailable = playerSpawnLogic ~= nil,
        spawnPhases = {},
        currentSpawns = {}
    }
    
    if playerSpawnLogic then
        results.currentSpawns = playerSpawnLogic:GetAllSpawnStatuses()
        
        if TEST_CONFIG.enableDetailedLogging then
            print("üìã Current spawn processes:")
            for userId, status in pairs(results.currentSpawns) do
                local player = Players:GetPlayerByUserId(userId)
                local playerName = player and player.Name or "Unknown"
                print("  üë§ " .. playerName .. " ‚Üí " .. status.currentPhase .. " (" .. status.retryCount .. " retries)")
            end
        end
    else
        warn("‚ö†Ô∏è PlayerSpawnLogic not directly accessible (may be internal to SystemEventConnections)")
        results.success = true -- This is expected in current architecture
    end
    
    return results
end

-- ========================================
-- RECORDING BINDINGS TEST
-- ========================================

function EventConnectionsTest:TestRecordingBindings()
    print("üé¨ Testing Recording Bindings...")
    
    local recordingManager = _G.GetRecordingSessionManager()
    local gameStateManager = _G.GetGameStateEventManager()
    
    local results = {
        success = true,
        recordingManagerAvailable = recordingManager ~= nil,
        gameStateManagerAvailable = gameStateManager ~= nil,
        recordingMethods = {}
    }
    
    if recordingManager then
        results.recordingMethods = {
            startRecording = recordingManager.StartRecording ~= nil,
            stopRecording = recordingManager.StopRecording ~= nil,
            pauseRecording = recordingManager.PauseRecording ~= nil,
            resumeRecording = recordingManager.ResumeRecording ~= nil
        }
        
        if TEST_CONFIG.enableDetailedLogging then
            for method, available in pairs(results.recordingMethods) do
                local status = available and "‚úÖ" or "‚ùå"
                print("  " .. status .. " " .. method .. " method")
            end
        end
    end
    
    return results
end

-- ========================================
-- ANALYTICS BINDINGS TEST
-- ========================================

function EventConnectionsTest:TestAnalyticsBindings()
    print("üìä Testing Analytics Bindings...")
    
    local analyticsService = _G.GetAnalyticsService()
    local gameStateManager = _G.GetGameStateEventManager()
    
    local results = {
        success = true,
        analyticsServiceAvailable = analyticsService ~= nil,
        gameStateManagerAvailable = gameStateManager ~= nil,
        analyticsMethods = {}
    }
    
    if analyticsService then
        results.analyticsMethods = {
            trackEvent = analyticsService.TrackEvent ~= nil,
            trackPlayerJoin = analyticsService.TrackPlayerJoin ~= nil,
            trackPlayerLeave = analyticsService.TrackPlayerLeave ~= nil
        }
        
        if TEST_CONFIG.enableDetailedLogging then
            for method, available in pairs(results.analyticsMethods) do
                local status = available and "‚úÖ" or "‚ùå"
                print("  " .. status .. " " .. method .. " method")
            end
        end
    end
    
    return results
end

-- ========================================
-- SYSTEM RESET BINDINGS TEST
-- ========================================

function EventConnectionsTest:TestSystemResetBindings()
    print("üîÑ Testing System Reset Bindings...")
    
    local gameStateManager = _G.GetGameStateEventManager()
    local mainController = _G.GetMainGameController()
    
    local results = {
        success = true,
        gameStateManagerAvailable = gameStateManager ~= nil,
        mainControllerAvailable = mainController ~= nil,
        resetMethods = {}
    }
    
    if mainController then
        results.resetMethods = {
            resetPlayerGame = mainController.ResetPlayerGame ~= nil,
            clearPlayerData = mainController.ClearPlayerData ~= nil,
            preparePlayerForGame = mainController.PreparePlayerForGame ~= nil
        }
        
        if TEST_CONFIG.enableDetailedLogging then
            for method, available in pairs(results.resetMethods) do
                local status = available and "‚úÖ" or "‚ùå"
                print("  " .. status .. " " .. method .. " method")
            end
        end
    end
    
    return results
end

-- ========================================
-- RESULTS REPORTING
-- ========================================

function EventConnectionsTest:PrintTestResults(results)
    print("\nüìä Event Connections Test Results:")
    print("=" .. string.rep("=", 50))
    
    local totalTests = 0
    local passedTests = 0
    
    for testName, result in pairs(results) do
        totalTests = totalTests + 1
        local success = result.success ~= false
        if success then passedTests = passedTests + 1 end
        
        local status = success and "‚úÖ PASS" or "‚ùå FAIL"
        print(status .. " " .. testName)
        
        if not success and result.error then
            print("    Error: " .. result.error)
        end
    end
    
    print("=" .. string.rep("=", 50))
    print("üìà Summary: " .. passedTests .. "/" .. totalTests .. " tests passed")
    
    if passedTests == totalTests then
        print("üéâ All event connections and system bindings are working correctly!")
    else
        warn("‚ö†Ô∏è Some tests failed - check the implementation")
    end
    
    return {
        totalTests = totalTests,
        passedTests = passedTests,
        success = passedTests == totalTests
    }
end

-- Manual test triggers for debugging
function EventConnectionsTest:TestPlayerSpawnManual(player)
    if not player then
        warn("‚ùå No player provided for manual spawn test")
        return
    end
    
    print("üß™ Manual player spawn test for: " .. player.Name)
    
    local systemConnections = _G.GetSystemEventConnections()
    if systemConnections and systemConnections.HandlePlayerAdded then
        systemConnections:HandlePlayerAdded(player)
        print("‚úÖ Manual spawn test triggered")
    else
        warn("‚ùå Cannot trigger manual spawn test - SystemEventConnections missing")
    end
end

function EventConnectionsTest:TestGameStateChangeManual(player, newState)
    if not player then
        warn("‚ùå No player provided for manual game state test")
        return
    end
    
    newState = newState or "PLAYING"
    print("üß™ Manual game state change test: " .. player.Name .. " ‚Üí " .. newState)
    
    local gameStateManager = _G.GetGameStateEventManager()
    if gameStateManager and gameStateManager.ChangeGameState then
        gameStateManager:ChangeGameState(player, newState, {testData = true})
        print("‚úÖ Manual game state test triggered")
    else
        warn("‚ùå Cannot trigger manual game state test - GameStateEventManager missing")
    end
end

-- Global accessors for manual testing
_G.TestEventConnections = EventConnectionsTest
_G.RunEventConnectionsTests = function()
    return EventConnectionsTest:RunAllTests()
end

-- Auto-initialize
spawn(function()
    wait(12) -- Wait for all other systems
    EventConnectionsTest:Initialize()
end)

return EventConnectionsTest
