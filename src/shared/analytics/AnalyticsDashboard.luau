-- AnalyticsDashboard.luau
-- Real-time analytics dashboard with business intelligence capabilities
-- Provides comprehensive data visualization and insights for game metrics

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local SafeRequire = require(ReplicatedStorage.Shared.utils.SafeRequire)

local AnalyticsDashboard = {}

-- ========================================
-- DASHBOARD CONFIGURATION
-- ========================================

local DASHBOARD_CONFIG = {
    -- Update intervals
    updateIntervals = {
        realtime = 5,        -- 5 seconds
        nearRealtime = 30,   -- 30 seconds
        standard = 300,      -- 5 minutes
        batch = 3600         -- 1 hour
    },
    
    -- Data retention
    dataRetention = {
        realtime = 3600,     -- 1 hour
        hourly = 168 * 3600, -- 1 week
        daily = 90 * 86400,  -- 90 days
        monthly = 365 * 86400 -- 1 year
    },
    
    -- Chart configurations
    charts = {
        playerActivity = {
            type = "line",
            timeRange = "24h",
            refreshInterval = 60,
            metrics = {"active_players", "new_players", "returning_players"}
        },
        
        gameMetrics = {
            type = "multi",
            timeRange = "7d",
            refreshInterval = 300,
            metrics = {"session_duration", "retention_rate", "engagement_score"}
        },
        
        monetization = {
            type = "area",
            timeRange = "30d",
            refreshInterval = 3600,
            metrics = {"revenue", "purchases", "arpu", "arppu"}
        },
        
        performance = {
            type = "gauge",
            timeRange = "1h",
            refreshInterval = 30,
            metrics = {"fps", "ping", "load_time", "error_rate"}
        }
    },
    
    -- Alert thresholds
    alerts = {
        playerDrop = {threshold = 0.2, timeWindow = 300},      -- 20% drop in 5 minutes
        errorRate = {threshold = 0.05, timeWindow = 600},      -- 5% error rate in 10 minutes
        revenueDrop = {threshold = 0.3, timeWindow = 3600},    -- 30% revenue drop in 1 hour
        performanceDeg = {threshold = 0.25, timeWindow = 900}  -- 25% performance drop in 15 minutes
    }
}

-- ========================================
-- DASHBOARD STATE
-- ========================================

local DashboardState = {
    -- Data storage
    realtimeData = {},
    historicalData = {},
    aggregatedData = {},
    
    -- Metrics tracking
    currentMetrics = {},
    metricHistory = {},
    
    -- Dashboard components
    widgets = {},
    charts = {},
    alerts = {},
    
    -- Update management
    updateTimers = {},
    lastUpdates = {},
    
    -- User preferences
    userSettings = {},
    customDashboards = {},
    
    -- Statistics
    stats = {
        totalDataPoints = 0,
        chartsRendered = 0,
        alertsGenerated = 0,
        dashboardViews = 0,
        averageLoadTime = 0
    }
}

function AnalyticsDashboard.initialize()
    print("ðŸ“Š Initializing AnalyticsDashboard...")
    
    -- Set up data collection
    AnalyticsDashboard.setupDataCollection()
    
    -- Initialize dashboard components
    AnalyticsDashboard.initializeDashboardComponents()
    
    -- Set up real-time updates
    AnalyticsDashboard.setupRealtimeUpdates()
    
    -- Initialize alert system
    AnalyticsDashboard.initializeAlerts()
    
    -- Set up data aggregation
    AnalyticsDashboard.setupDataAggregation()
    
    print("ðŸ“Š AnalyticsDashboard initialized successfully")
end

-- ========================================
-- DATA COLLECTION
-- ========================================

function AnalyticsDashboard.setupDataCollection()
    -- Initialize data collectors
    DashboardState.dataCollectors = {
        playerMetrics = AnalyticsDashboard.createPlayerMetricsCollector(),
        gameMetrics = AnalyticsDashboard.createGameMetricsCollector(),
        performanceMetrics = AnalyticsDashboard.createPerformanceMetricsCollector(),
        businessMetrics = AnalyticsDashboard.createBusinessMetricsCollector()
    }
    
    -- Start collection processes
    for collectorName, collector in pairs(DashboardState.dataCollectors) do
        collector:start()
    end
    
    print("ðŸ“ˆ Data collection systems started")
end

function AnalyticsDashboard.createPlayerMetricsCollector()
    return {
        name = "player_metrics",
        interval = DASHBOARD_CONFIG.updateIntervals.realtime,
        
        start = function(self)
            spawn(function()
                while true do
                    AnalyticsDashboard.collectPlayerMetrics()
                    task.wait(self.interval)
                end
            end)
        end
    }
end

function AnalyticsDashboard.createGameMetricsCollector()
    return {
        name = "game_metrics",
        interval = DASHBOARD_CONFIG.updateIntervals.nearRealtime,
        
        start = function(self)
            spawn(function()
                while true do
                    AnalyticsDashboard.collectGameMetrics()
                    task.wait(self.interval)
                end
            end)
        end
    }
end

function AnalyticsDashboard.createPerformanceMetricsCollector()
    return {
        name = "performance_metrics",
        interval = DASHBOARD_CONFIG.updateIntervals.realtime,
        
        start = function(self)
            spawn(function()
                while true do
                    AnalyticsDashboard.collectPerformanceMetrics()
                    task.wait(self.interval)
                end
            end)
        end
    }
end

function AnalyticsDashboard.createBusinessMetricsCollector()
    return {
        name = "business_metrics",
        interval = DASHBOARD_CONFIG.updateIntervals.standard,
        
        start = function(self)
            spawn(function()
                while true do
                    AnalyticsDashboard.collectBusinessMetrics()
                    task.wait(self.interval)
                end
            end)
        end
    }
end

function AnalyticsDashboard.collectPlayerMetrics()
    local timestamp = tick()
    local playerCount = #Players:GetPlayers()
    
    local metrics = {
        active_players = playerCount,
        new_players = AnalyticsDashboard.getNewPlayersCount(),
        returning_players = AnalyticsDashboard.getReturningPlayersCount(),
        peak_concurrent = AnalyticsDashboard.updatePeakConcurrent(playerCount),
        timestamp = timestamp
    }
    
    AnalyticsDashboard.storeMetrics("player", metrics)
end

function AnalyticsDashboard.collectGameMetrics()
    local timestamp = tick()
    
    local metrics = {
        session_duration = AnalyticsDashboard.getAverageSessionDuration(),
        retention_rate = AnalyticsDashboard.calculateRetentionRate(),
        engagement_score = AnalyticsDashboard.calculateEngagementScore(),
        churn_rate = AnalyticsDashboard.calculateChurnRate(),
        level_completion_rate = AnalyticsDashboard.getLevelCompletionRate(),
        timestamp = timestamp
    }
    
    AnalyticsDashboard.storeMetrics("game", metrics)
end

function AnalyticsDashboard.collectPerformanceMetrics()
    local timestamp = tick()
    local heartbeat = RunService.Heartbeat
    
    local metrics = {
        fps = 1 / heartbeat:Wait(),
        ping = AnalyticsDashboard.measurePing(),
        memory_usage = AnalyticsDashboard.getMemoryUsage(),
        load_time = AnalyticsDashboard.getAverageLoadTime(),
        error_rate = AnalyticsDashboard.getErrorRate(),
        timestamp = timestamp
    }
    
    AnalyticsDashboard.storeMetrics("performance", metrics)
end

function AnalyticsDashboard.collectBusinessMetrics()
    local timestamp = tick()
    
    local metrics = {
        revenue = AnalyticsDashboard.calculateRevenue(),
        purchases = AnalyticsDashboard.getPurchaseCount(),
        arpu = AnalyticsDashboard.calculateARPU(),
        arppu = AnalyticsDashboard.calculateARPPU(),
        ltv = AnalyticsDashboard.calculateLTV(),
        conversion_rate = AnalyticsDashboard.getConversionRate(),
        timestamp = timestamp
    }
    
    AnalyticsDashboard.storeMetrics("business", metrics)
end

function AnalyticsDashboard.storeMetrics(category, metrics)
    local timestamp = metrics.timestamp
    
    -- Store in realtime data
    if not DashboardState.realtimeData[category] then
        DashboardState.realtimeData[category] = {}
    end
    
    table.insert(DashboardState.realtimeData[category], metrics)
    
    -- Limit realtime data size
    local retention = DASHBOARD_CONFIG.dataRetention.realtime
    while #DashboardState.realtimeData[category] > 0 do
        local oldest = DashboardState.realtimeData[category][1]
        if timestamp - oldest.timestamp > retention then
            table.remove(DashboardState.realtimeData[category], 1)
        else
            break
        end
    end
    
    -- Update current metrics
    DashboardState.currentMetrics[category] = metrics
    
    -- Update statistics
    DashboardState.stats.totalDataPoints = DashboardState.stats.totalDataPoints + 1
end

-- ========================================
-- DASHBOARD COMPONENTS
-- ========================================

function AnalyticsDashboard.initializeDashboardComponents()
    -- Create dashboard widgets
    DashboardState.widgets = {
        playerActivity = AnalyticsDashboard.createPlayerActivityWidget(),
        gamePerformance = AnalyticsDashboard.createGamePerformanceWidget(),
        monetization = AnalyticsDashboard.createMonetizationWidget(),
        realTimeStats = AnalyticsDashboard.createRealTimeStatsWidget(),
        alertsPanel = AnalyticsDashboard.createAlertsPanelWidget()
    }
    
    -- Initialize charts
    AnalyticsDashboard.initializeCharts()
    
    print("ðŸŽ›ï¸ Dashboard components initialized")
end

function AnalyticsDashboard.createPlayerActivityWidget()
    return {
        name = "Player Activity",
        type = "line_chart",
        metrics = {"active_players", "new_players", "returning_players"},
        timeRange = "24h",
        refreshInterval = 60,
        
        getData = function(self)
            return AnalyticsDashboard.getPlayerActivityData(self.timeRange)
        end,
        
        render = function(self)
            local data = self:getData()
            return AnalyticsDashboard.renderLineChart(data, self.metrics)
        end
    }
end

function AnalyticsDashboard.createGamePerformanceWidget()
    return {
        name = "Game Performance",
        type = "gauge_chart",
        metrics = {"fps", "ping", "error_rate"},
        refreshInterval = 30,
        
        getData = function(self)
            return DashboardState.currentMetrics.performance or {}
        end,
        
        render = function(self)
            local data = self:getData()
            return AnalyticsDashboard.renderGaugeChart(data, self.metrics)
        end
    }
end

function AnalyticsDashboard.createMonetizationWidget()
    return {
        name = "Monetization",
        type = "area_chart",
        metrics = {"revenue", "purchases", "arpu"},
        timeRange = "30d",
        refreshInterval = 3600,
        
        getData = function(self)
            return AnalyticsDashboard.getMonetizationData(self.timeRange)
        end,
        
        render = function(self)
            local data = self:getData()
            return AnalyticsDashboard.renderAreaChart(data, self.metrics)
        end
    }
end

function AnalyticsDashboard.createRealTimeStatsWidget()
    return {
        name = "Real-time Stats",
        type = "stats_panel",
        refreshInterval = 5,
        
        getData = function(self)
            return {
                activePlayers = DashboardState.currentMetrics.player and 
                    DashboardState.currentMetrics.player.active_players or 0,
                fps = DashboardState.currentMetrics.performance and 
                    DashboardState.currentMetrics.performance.fps or 0,
                revenue = DashboardState.currentMetrics.business and 
                    DashboardState.currentMetrics.business.revenue or 0,
                errorRate = DashboardState.currentMetrics.performance and 
                    DashboardState.currentMetrics.performance.error_rate or 0
            }
        end,
        
        render = function(self)
            local data = self:getData()
            return AnalyticsDashboard.renderStatsPanel(data)
        end
    }
end

function AnalyticsDashboard.createAlertsPanelWidget()
    return {
        name = "Alerts",
        type = "alerts_panel",
        
        getData = function(self)
            return DashboardState.alerts
        end,
        
        render = function(self)
            local data = self:getData()
            return AnalyticsDashboard.renderAlertsPanel(data)
        end
    }
end

function AnalyticsDashboard.initializeCharts()
    DashboardState.charts = {}
    
    for chartName, chartConfig in pairs(DASHBOARD_CONFIG.charts) do
        DashboardState.charts[chartName] = {
            config = chartConfig,
            data = {},
            lastUpdate = 0,
            
            update = function(self)
                self.data = AnalyticsDashboard.getChartData(chartName, self.config)
                self.lastUpdate = tick()
            end,
            
            render = function(self)
                return AnalyticsDashboard.renderChart(self.config.type, self.data, self.config)
            end
        }
    end
end

-- ========================================
-- REAL-TIME UPDATES
-- ========================================

function AnalyticsDashboard.setupRealtimeUpdates()
    -- Set up update timers for each widget
    for widgetName, widget in pairs(DashboardState.widgets) do
        if widget.refreshInterval then
            DashboardState.updateTimers[widgetName] = widget.refreshInterval
            DashboardState.lastUpdates[widgetName] = 0
        end
    end
    
    -- Start update loop
    spawn(function()
        while true do
            AnalyticsDashboard.updateDashboardComponents()
            task.wait(1) -- Check every second
        end
    end)
    
    print("ðŸ”„ Real-time updates enabled")
end

function AnalyticsDashboard.updateDashboardComponents()
    local currentTime = tick()
    
    for widgetName, widget in pairs(DashboardState.widgets) do
        local timer = DashboardState.updateTimers[widgetName]
        local lastUpdate = DashboardState.lastUpdates[widgetName]
        
        if timer and currentTime - lastUpdate >= timer then
            AnalyticsDashboard.updateWidget(widgetName, widget)
            DashboardState.lastUpdates[widgetName] = currentTime
        end
    end
    
    -- Update charts
    for chartName, chart in pairs(DashboardState.charts) do
        local config = chart.config
        if currentTime - chart.lastUpdate >= config.refreshInterval then
            chart:update()
        end
    end
end

function AnalyticsDashboard.updateWidget(widgetName, widget)
    local startTime = tick()
    
    -- Update widget data and render
    local rendered = widget:render()
    
    local updateTime = tick() - startTime
    
    -- Update statistics
    DashboardState.stats.averageLoadTime = 
        (DashboardState.stats.averageLoadTime + updateTime) / 2
    
    print(string.format("ðŸ”„ Updated widget %s (%.3fs)", widgetName, updateTime))
end

-- ========================================
-- ALERT SYSTEM
-- ========================================

function AnalyticsDashboard.initializeAlerts()
    DashboardState.alertSystem = {
        activeAlerts = {},
        alertHistory = {},
        processors = AnalyticsDashboard.createAlertProcessors()
    }
    
    -- Start alert monitoring
    spawn(function()
        while true do
            AnalyticsDashboard.processAlerts()
            task.wait(30) -- Check every 30 seconds
        end
    end)
    
    print("ðŸš¨ Alert system initialized")
end

function AnalyticsDashboard.createAlertProcessors()
    return {
        playerDrop = AnalyticsDashboard.createPlayerDropProcessor(),
        errorRate = AnalyticsDashboard.createErrorRateProcessor(),
        revenueDrop = AnalyticsDashboard.createRevenueDropProcessor(),
        performanceDeg = AnalyticsDashboard.createPerformanceProcessor()
    }
end

function AnalyticsDashboard.createPlayerDropProcessor()
    return {
        name = "player_drop",
        threshold = DASHBOARD_CONFIG.alerts.playerDrop.threshold,
        timeWindow = DASHBOARD_CONFIG.alerts.playerDrop.timeWindow,
        
        check = function(self)
            return AnalyticsDashboard.checkPlayerDropAlert(self.threshold, self.timeWindow)
        end
    }
end

function AnalyticsDashboard.createErrorRateProcessor()
    return {
        name = "error_rate",
        threshold = DASHBOARD_CONFIG.alerts.errorRate.threshold,
        timeWindow = DASHBOARD_CONFIG.alerts.errorRate.timeWindow,
        
        check = function(self)
            return AnalyticsDashboard.checkErrorRateAlert(self.threshold, self.timeWindow)
        end
    }
end

function AnalyticsDashboard.createRevenueDropProcessor()
    return {
        name = "revenue_drop",
        threshold = DASHBOARD_CONFIG.alerts.revenueDrop.threshold,
        timeWindow = DASHBOARD_CONFIG.alerts.revenueDrop.timeWindow,
        
        check = function(self)
            return AnalyticsDashboard.checkRevenueDropAlert(self.threshold, self.timeWindow)
        end
    }
end

function AnalyticsDashboard.createPerformanceProcessor()
    return {
        name = "performance_degradation",
        threshold = DASHBOARD_CONFIG.alerts.performanceDeg.threshold,
        timeWindow = DASHBOARD_CONFIG.alerts.performanceDeg.timeWindow,
        
        check = function(self)
            return AnalyticsDashboard.checkPerformanceAlert(self.threshold, self.timeWindow)
        end
    }
end

function AnalyticsDashboard.processAlerts()
    for processorName, processor in pairs(DashboardState.alertSystem.processors) do
        local alert = processor:check()
        if alert then
            AnalyticsDashboard.triggerAlert(alert)
        end
    end
end

function AnalyticsDashboard.checkPlayerDropAlert(threshold, timeWindow)
    local playerData = DashboardState.realtimeData.player
    if not playerData or #playerData < 2 then return nil end
    
    local currentTime = tick()
    local recentData = {}
    
    for _, data in ipairs(playerData) do
        if currentTime - data.timestamp <= timeWindow then
            table.insert(recentData, data)
        end
    end
    
    if #recentData < 2 then return nil end
    
    local latest = recentData[#recentData].active_players
    local earliest = recentData[1].active_players
    
    if earliest > 0 then
        local dropPercent = (earliest - latest) / earliest
        if dropPercent >= threshold then
            return {
                type = "player_drop",
                severity = "high",
                message = string.format("Player count dropped by %.1f%% in %d seconds", 
                    dropPercent * 100, timeWindow),
                data = {
                    dropPercent = dropPercent,
                    previousCount = earliest,
                    currentCount = latest,
                    timeWindow = timeWindow
                },
                timestamp = currentTime
            }
        end
    end
    
    return nil
end

function AnalyticsDashboard.checkErrorRateAlert(threshold, timeWindow)
    local perfData = DashboardState.realtimeData.performance
    if not perfData or #perfData == 0 then return nil end
    
    local currentTime = tick()
    local recentErrors = {}
    
    for _, data in ipairs(perfData) do
        if currentTime - data.timestamp <= timeWindow then
            table.insert(recentErrors, data.error_rate or 0)
        end
    end
    
    if #recentErrors == 0 then return nil end
    
    local avgErrorRate = 0
    for _, rate in ipairs(recentErrors) do
        avgErrorRate = avgErrorRate + rate
    end
    avgErrorRate = avgErrorRate / #recentErrors
    
    if avgErrorRate >= threshold then
        return {
            type = "error_rate",
            severity = "medium",
            message = string.format("Error rate is %.1f%% (threshold: %.1f%%)", 
                avgErrorRate * 100, threshold * 100),
            data = {
                errorRate = avgErrorRate,
                threshold = threshold,
                timeWindow = timeWindow
            },
            timestamp = currentTime
        }
    end
    
    return nil
end

function AnalyticsDashboard.checkRevenueDropAlert(threshold, timeWindow)
    -- Simulate revenue drop check
    local currentRevenue = math.random(800, 1200)
    local previousRevenue = math.random(1000, 1500)
    
    if previousRevenue > 0 then
        local dropPercent = (previousRevenue - currentRevenue) / previousRevenue
        if dropPercent >= threshold then
            return {
                type = "revenue_drop",
                severity = "high",
                message = string.format("Revenue dropped by %.1f%% in the last hour", 
                    dropPercent * 100),
                data = {
                    dropPercent = dropPercent,
                    previousRevenue = previousRevenue,
                    currentRevenue = currentRevenue
                },
                timestamp = tick()
            }
        end
    end
    
    return nil
end

function AnalyticsDashboard.checkPerformanceAlert(threshold, timeWindow)
    local perfData = DashboardState.currentMetrics.performance
    if not perfData then return nil end
    
    local fps = perfData.fps or 60
    local ping = perfData.ping or 50
    
    -- Check if performance metrics are below acceptable levels
    if fps < 30 or ping > 200 then
        return {
            type = "performance_degradation",
            severity = "medium",
            message = string.format("Performance degraded: %.1f FPS, %.1fms ping", fps, ping),
            data = {
                fps = fps,
                ping = ping,
                threshold = threshold
            },
            timestamp = tick()
        }
    end
    
    return nil
end

function AnalyticsDashboard.triggerAlert(alert)
    alert.id = HttpService:GenerateGUID(false)
    
    -- Add to active alerts
    table.insert(DashboardState.alertSystem.activeAlerts, alert)
    
    -- Add to history
    table.insert(DashboardState.alertSystem.alertHistory, alert)
    
    -- Update statistics
    DashboardState.stats.alertsGenerated = DashboardState.stats.alertsGenerated + 1
    
    print(string.format("ðŸš¨ ALERT [%s]: %s", alert.severity:upper(), alert.message))
    
    -- Send alert to external systems
    AnalyticsDashboard.sendAlertNotification(alert)
end

function AnalyticsDashboard.sendAlertNotification(alert)
    -- Simulate sending alert to external notification systems
    local notificationData = {
        alertId = alert.id,
        type = alert.type,
        severity = alert.severity,
        message = alert.message,
        timestamp = alert.timestamp,
        gameId = game.GameId,
        placeId = game.PlaceId
    }
    
    -- Send to monitoring systems, Slack, email, etc.
    print(string.format("ðŸ“§ Alert notification sent: %s", alert.type))
end

-- ========================================
-- DATA AGGREGATION
-- ========================================

function AnalyticsDashboard.setupDataAggregation()
    -- Start aggregation processes
    spawn(function()
        while true do
            AnalyticsDashboard.aggregateHourlyData()
            task.wait(3600) -- Run every hour
        end
    end)
    
    spawn(function()
        while true do
            AnalyticsDashboard.aggregateDailyData()
            task.wait(86400) -- Run every day
        end
    end)
    
    print("ðŸ“Š Data aggregation processes started")
end

function AnalyticsDashboard.aggregateHourlyData()
    local currentHour = math.floor(tick() / 3600)
    
    for category, data in pairs(DashboardState.realtimeData) do
        if #data > 0 then
            local aggregated = AnalyticsDashboard.aggregateDataPoints(data, "hourly")
            
            if not DashboardState.aggregatedData.hourly then
                DashboardState.aggregatedData.hourly = {}
            end
            if not DashboardState.aggregatedData.hourly[category] then
                DashboardState.aggregatedData.hourly[category] = {}
            end
            
            DashboardState.aggregatedData.hourly[category][currentHour] = aggregated
        end
    end
    
    print("ðŸ“Š Hourly data aggregation completed")
end

function AnalyticsDashboard.aggregateDailyData()
    local currentDay = math.floor(tick() / 86400)
    
    for category, hourlyData in pairs(DashboardState.aggregatedData.hourly or {}) do
        if next(hourlyData) then
            local aggregated = AnalyticsDashboard.aggregateDataPoints(hourlyData, "daily")
            
            if not DashboardState.aggregatedData.daily then
                DashboardState.aggregatedData.daily = {}
            end
            if not DashboardState.aggregatedData.daily[category] then
                DashboardState.aggregatedData.daily[category] = {}
            end
            
            DashboardState.aggregatedData.daily[category][currentDay] = aggregated
        end
    end
    
    print("ðŸ“Š Daily data aggregation completed")
end

function AnalyticsDashboard.aggregateDataPoints(dataPoints, aggregationType)
    local aggregated = {
        timestamp = tick(),
        aggregationType = aggregationType,
        count = #dataPoints
    }
    
    -- Calculate aggregations for each metric
    local metricSums = {}
    local metricCounts = {}
    
    for _, dataPoint in pairs(dataPoints) do
        for metric, value in pairs(dataPoint) do
            if type(value) == "number" and metric ~= "timestamp" then
                metricSums[metric] = (metricSums[metric] or 0) + value
                metricCounts[metric] = (metricCounts[metric] or 0) + 1
            end
        end
    end
    
    -- Calculate averages, mins, maxs
    for metric, sum in pairs(metricSums) do
        local count = metricCounts[metric]
        aggregated[metric .. "_avg"] = sum / count
        aggregated[metric .. "_sum"] = sum
        aggregated[metric .. "_count"] = count
        
        -- Calculate min and max
        local values = {}
        for _, dataPoint in pairs(dataPoints) do
            if dataPoint[metric] then
                table.insert(values, dataPoint[metric])
            end
        end
        
        if #values > 0 then
            table.sort(values)
            aggregated[metric .. "_min"] = values[1]
            aggregated[metric .. "_max"] = values[#values]
            aggregated[metric .. "_median"] = values[math.ceil(#values / 2)]
        end
    end
    
    return aggregated
end

-- ========================================
-- CHART RENDERING (SIMULATED)
-- ========================================

function AnalyticsDashboard.renderLineChart(data, metrics)
    local chartData = {
        type = "line",
        metrics = metrics,
        dataPoints = #data,
        timeRange = "Generated line chart",
        rendered = true,
        timestamp = tick()
    }
    
    DashboardState.stats.chartsRendered = DashboardState.stats.chartsRendered + 1
    return chartData
end

function AnalyticsDashboard.renderAreaChart(data, metrics)
    local chartData = {
        type = "area",
        metrics = metrics,
        dataPoints = #data,
        timeRange = "Generated area chart",
        rendered = true,
        timestamp = tick()
    }
    
    DashboardState.stats.chartsRendered = DashboardState.stats.chartsRendered + 1
    return chartData
end

function AnalyticsDashboard.renderGaugeChart(data, metrics)
    local chartData = {
        type = "gauge",
        metrics = metrics,
        currentValues = data,
        rendered = true,
        timestamp = tick()
    }
    
    DashboardState.stats.chartsRendered = DashboardState.stats.chartsRendered + 1
    return chartData
end

function AnalyticsDashboard.renderStatsPanel(data)
    local panelData = {
        type = "stats_panel",
        stats = data,
        rendered = true,
        timestamp = tick()
    }
    
    return panelData
end

function AnalyticsDashboard.renderAlertsPanel(alerts)
    local panelData = {
        type = "alerts_panel",
        alertCount = #alerts,
        alerts = alerts,
        rendered = true,
        timestamp = tick()
    }
    
    return panelData
end

-- ========================================
-- UTILITY FUNCTIONS
-- ========================================

function AnalyticsDashboard.getNewPlayersCount()
    return math.random(0, 5)
end

function AnalyticsDashboard.getReturningPlayersCount()
    return math.random(5, 15)
end

function AnalyticsDashboard.updatePeakConcurrent(currentCount)
    local peak = DashboardState.peakConcurrent or 0
    if currentCount > peak then
        DashboardState.peakConcurrent = currentCount
        return currentCount
    end
    return peak
end

function AnalyticsDashboard.getAverageSessionDuration()
    return math.random(300, 1800) -- 5-30 minutes
end

function AnalyticsDashboard.calculateRetentionRate()
    return math.random(60, 85) / 100 -- 60-85%
end

function AnalyticsDashboard.calculateEngagementScore()
    return math.random(70, 95) / 100 -- 70-95%
end

function AnalyticsDashboard.calculateChurnRate()
    return math.random(5, 20) / 100 -- 5-20%
end

function AnalyticsDashboard.getLevelCompletionRate()
    return math.random(40, 80) / 100 -- 40-80%
end

function AnalyticsDashboard.measurePing()
    return math.random(20, 150) -- 20-150ms
end

function AnalyticsDashboard.getMemoryUsage()
    return math.random(50, 200) -- 50-200MB
end

function AnalyticsDashboard.getAverageLoadTime()
    return math.random(2, 10) -- 2-10 seconds
end

function AnalyticsDashboard.getErrorRate()
    return math.random(0, 10) / 100 -- 0-10%
end

function AnalyticsDashboard.calculateRevenue()
    return math.random(500, 2000) -- $500-2000
end

function AnalyticsDashboard.getPurchaseCount()
    return math.random(10, 100)
end

function AnalyticsDashboard.calculateARPU()
    return math.random(5, 25) -- $5-25
end

function AnalyticsDashboard.calculateARPPU()
    return math.random(15, 50) -- $15-50
end

function AnalyticsDashboard.calculateLTV()
    return math.random(50, 200) -- $50-200
end

function AnalyticsDashboard.getConversionRate()
    return math.random(2, 8) / 100 -- 2-8%
end

-- ========================================
-- PUBLIC API
-- ========================================

function AnalyticsDashboard.runDashboardDemo()
    print("ðŸ“Š Running analytics dashboard demonstration...")
    
    -- Simulate data collection
    print("  ðŸ“ˆ Collecting metrics...")
    AnalyticsDashboard.collectPlayerMetrics()
    AnalyticsDashboard.collectGameMetrics()
    AnalyticsDashboard.collectPerformanceMetrics()
    AnalyticsDashboard.collectBusinessMetrics()
    
    task.wait(1)
    
    -- Update dashboard widgets
    print("  ðŸŽ›ï¸ Updating dashboard widgets...")
    for widgetName, widget in pairs(DashboardState.widgets) do
        local rendered = widget:render()
        print(string.format("    %s: %s", widgetName, rendered.type))
    end
    
    -- Check for alerts
    print("  ðŸš¨ Checking for alerts...")
    AnalyticsDashboard.processAlerts()
    
    -- Show current metrics
    print("  ðŸ“Š Current Metrics:")
    if DashboardState.currentMetrics.player then
        print(string.format("    Active Players: %d", 
            DashboardState.currentMetrics.player.active_players))
    end
    if DashboardState.currentMetrics.performance then
        print(string.format("    FPS: %.1f", 
            DashboardState.currentMetrics.performance.fps))
        print(string.format("    Ping: %.1fms", 
            DashboardState.currentMetrics.performance.ping))
    end
    if DashboardState.currentMetrics.business then
        print(string.format("    Revenue: $%.2f", 
            DashboardState.currentMetrics.business.revenue))
    end
    
    -- Show alerts
    if #DashboardState.alertSystem.activeAlerts > 0 then
        print("  ðŸš¨ Active Alerts:")
        for _, alert in ipairs(DashboardState.alertSystem.activeAlerts) do
            print(string.format("    [%s] %s", alert.severity:upper(), alert.message))
        end
    else
        print("  âœ… No active alerts")
    end
    
    -- Show statistics
    local stats = AnalyticsDashboard.getDashboardStats()
    print("  ðŸ“ˆ Dashboard Statistics:")
    print(string.format("    Total data points: %d", stats.totalDataPoints))
    print(string.format("    Charts rendered: %d", stats.chartsRendered))
    print(string.format("    Alerts generated: %d", stats.alertsGenerated))
    print(string.format("    Average load time: %.3fs", stats.averageLoadTime))
    
    print("ðŸ“Š Analytics dashboard demonstration completed")
end

function AnalyticsDashboard.getDashboardStats()
    return DashboardState.stats
end

function AnalyticsDashboard.getCurrentMetrics()
    return DashboardState.currentMetrics
end

function AnalyticsDashboard.getActiveAlerts()
    return DashboardState.alertSystem.activeAlerts
end

function AnalyticsDashboard.getDashboardWidgets()
    return DashboardState.widgets
end

-- Export API
AnalyticsDashboard.collectPlayerMetrics = AnalyticsDashboard.collectPlayerMetrics
AnalyticsDashboard.collectGameMetrics = AnalyticsDashboard.collectGameMetrics
AnalyticsDashboard.collectPerformanceMetrics = AnalyticsDashboard.collectPerformanceMetrics
AnalyticsDashboard.collectBusinessMetrics = AnalyticsDashboard.collectBusinessMetrics

-- Initialize the analytics dashboard
AnalyticsDashboard.initialize()

print("ðŸ“Š AnalyticsDashboard loaded with real-time business intelligence")

return AnalyticsDashboard
